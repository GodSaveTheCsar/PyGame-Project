Index: sas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport sys\r\nfrom PyQt5 import uic  # Импортируем uic\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\r\nimport os\r\nfrom random import randrange\r\n\r\npygame.init()\r\nSIZE = 1000\r\nFPS = 50\r\nCELL_SIZE = 30\r\n\r\n\r\ndef fon_paint():\r\n    fon = pygame.transform.scale(load_image('fon.jpg'), (SIZE, SIZE))\r\n    screen = pygame.display.set_mode((SIZE, SIZE))\r\n    screen.blit(fon, (0, 0))\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    return image\r\n\r\n\r\nclass Tile(pygame.sprite.Sprite):\r\n    def __init__(self, x, y, sprites):\r\n        super().__init__(sprites)\r\n        self.x = x\r\n        self.y = y\r\n\r\n\r\nclass Pole(Tile):\r\n    def __init__(self, x, y, sprites):\r\n        super().__init__(x, y, sprites)\r\n        self.image = pygame.transform.scale(load_image('pole.png'), (30, 30))\r\n        self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n\r\n\r\nclass Castle(Tile):\r\n    def __init__(self, x, y, sprite):\r\n        super().__init__(x, y, sprite)\r\n        self.x = x\r\n        self.y = y\r\n        self.image = pygame.transform.scale(load_image('castle.jpg'), (30, 30))\r\n        self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n\r\n\r\nclass Player:\r\n    def __init__(self):\r\n        self.resources = {\r\n            'wood': 0,\r\n            'iron': 0,\r\n            'jewelry': 0,\r\n            'food': 0\r\n        }\r\n\r\n    def update_resources(self, name, val):\r\n        self.resourses[name] += val\r\n\r\n\r\nclass Resource(Tile):\r\n    def __init__(self, x, y, name, sprites):\r\n        super().__init__(x, y, sprites)\r\n        self.x = x\r\n        self.y = y\r\n        self.name = name\r\n        self.is_mining = False\r\n        if name == 'tree':\r\n            self.image = pygame.transform.scale(load_image('tree.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'iron':\r\n            self.image = pygame.transform.scale(load_image('iron.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'water':\r\n            self.image = pygame.transform.scale(load_image('water.jpg'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'food':\r\n            self.image = pygame.transform.scale(load_image('food.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'wood':\r\n            self.image = load_image('wood.png')\r\n            self.image = pygame.transform.scale(self.image, (28, 28))\r\n\r\n    def mine(self):\r\n        if not self.is_mining:\r\n            self.is_mining = True\r\n            print('добывается')\r\n\r\n\r\nclass MyWidget(QMainWindow):\r\n    def __init__(self):\r\n        global SIZE\r\n        super().__init__()\r\n        uic.loadUi('untitled.ui', self)  # Загружаем дизайн\r\n        self.is_pushed = False\r\n        self.pushButton.clicked.connect(self.run)\r\n        self.pushButton_2.clicked.connect(self.run)\r\n        self.pushButton_3.clicked.connect(self.run)\r\n\r\n    def run(self):\r\n        size = int(self.sender().text().split('(')[1][0:2])\r\n        self.size = size * 30\r\n        if size == 25:\r\n            self.size += 180\r\n        if size == 20:\r\n            self.size += 120\r\n        if size == 15:\r\n            self.size += 60\r\n        self.board_size = int(self.sender().text().split('(')[1][0:2])\r\n        self.topleft = int((self.size - size * CELL_SIZE) / 2)\r\n        self.is_pushed = True\r\n        self.close()\r\n\r\n\r\ndef start_screen():\r\n    pygame.init()\r\n    clock = pygame.time.Clock()\r\n    app = QApplication(sys.argv)\r\n    ex = MyWidget()\r\n    ex.show()\r\n    while True:\r\n        if ex.is_pushed:\r\n            return ex.size, ex.board_size, ex.topleft\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n        clock.tick(FPS)\r\n\r\n\r\ndef resources_screen(resources):\r\n    pygame.init()\r\n    resources_sprites = pygame.sprite.Group()\r\n    food = pygame.transform.scale(load_image('food_icon.png'), (50, 50))\r\n    image = load_image('frame_1.png')\r\n    iron = pygame.transform.scale(load_image('iron_icon.png'), (50, 50))\r\n    wood = pygame.transform.scale(load_image('wood_icon.png'), (50, 50))\r\n    brilliant = pygame.transform.scale(load_image('brilliant_icon.png'), (40, 50))\r\n    frame = pygame.sprite.Sprite(resources_sprites)\r\n    wood_i = pygame.sprite.Sprite(resources_sprites)\r\n    iron_i = pygame.sprite.Sprite(resources_sprites)\r\n    food_i = pygame.sprite.Sprite(resources_sprites)\r\n    brilliant_i = pygame.sprite.Sprite(resources_sprites)\r\n    frame.image = image\r\n    frame.rect = frame.image.get_rect()\r\n    frame.rect.x = 0\r\n    frame.rect.y = 0\r\n    iron_i.image = iron\r\n    iron_i.rect = iron_i.image.get_rect()\r\n    iron_i.rect.x = 0\r\n    iron_i.rect.y = 0\r\n    food_i.image = food\r\n    food_i.rect = food_i.image.get_rect()\r\n    food_i.rect.x = SIZE // 4\r\n    food_i.rect.y = 0\r\n    wood_i.image = wood\r\n    wood_i.rect = wood_i.image.get_rect()\r\n    wood_i.rect.x = 2 * SIZE // 4\r\n    wood_i.rect.y = 0\r\n    brilliant_i.image = brilliant\r\n    brilliant_i.rect = brilliant_i.image.get_rect()\r\n    brilliant_i.rect.x = 3 * SIZE // 4\r\n    brilliant_i.rect.y = 0\r\n    font = pygame.font.Font(None, 30)\r\n    resources_sprites.draw(screen)\r\n    count = -1\r\n    for i in resources:\r\n        count += 1\r\n        string_rendered = font.render(str(resources[i]), 1, pygame.Color('black'))\r\n        intro_rect = string_rendered.get_rect()\r\n        text_coord = count * SIZE // 4 + 50\r\n        intro_rect.left = text_coord\r\n        intro_rect.y = 15\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n\r\ndef builder_screen(builder):\r\n    global builder_sprites\r\n    if builder.is_clicked:\r\n        hammer = pygame.transform.scale(load_image('hammer.png'), (50, 50))\r\n        image = pygame.transform.scale(load_image('frame.png'), (300, 100))\r\n        frame = pygame.sprite.Sprite(builder_sprites)\r\n        build = pygame.sprite.Sprite(builder_sprites)\r\n        build.image = hammer\r\n        build.rect = build.image.get_rect()\r\n        build.rect.x = SIZE // 2 - 100\r\n        build.rect.y = SIZE + 25\r\n        frame.image = image\r\n        frame.rect = frame.image.get_rect()\r\n        frame.rect.x = SIZE // 2 - 150\r\n        frame.rect.y = SIZE\r\n        builder_sprites.draw(screen)\r\n        clock = pygame.time.Clock()\r\n        while frame.rect.y > SIZE - 100:\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    terminate()\r\n            frame.rect.y -= 600 / FPS\r\n            build.rect.y -= 600 / FPS\r\n            builder_sprites.draw(screen)\r\n            pygame.display.flip()\r\n            clock.tick(FPS)\r\n        if frame.rect.y != SIZE - 100:\r\n            frame.rect.y = SIZE - 100\r\n            build.rect.y = SIZE - 75\r\n    else:\r\n        builder_sprites = pygame.sprite.Group()\r\n\r\n\r\nclass Board():\r\n    def __init__(self):\r\n        self.width = self.height = BOARD_SIZE\r\n        self.list = [[0 for i in range(self.width)] for j in range(self.height)]\r\n        for i in range(self.width):\r\n            for j in range(self.height):\r\n                self.list[i][j] = Pole(i, j, all_sprites)\r\n        '''for x_water in range(0, SIZE // 30):\r\n            for y_water in range():\r\n                for x in range(3):\r\n                    for y in range(randrange(1, 5)):\r\n                        if x * (x_water + 1) > SIZE // 30 or y * (y_water + 1) > SIZE // 30:\r\n                            continue\r\n                        if self.list[x * (x_water + 1)][y * (y_water + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_water + 1)][y * (y_water + 1)] = Resource(x * (x_water + 1), y * (y_water + 1),\r\n                                                                                 'water', all_sprites)'''\r\n        for x_iron in range(0, self.width, 4):\r\n            for y_iron in range(0, self.width, 3):\r\n                for x in range(randrange(2, 4)):\r\n                    for y in range(randrange(2, 4)):\r\n                        if x * (x_iron + 1) >= self.width or y * (y_iron + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_iron + 1)][y * (y_iron + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_iron + 1)][y * (y_iron + 1)] = Resource(x * (x_iron + 1), y * (y_iron + 1),\r\n                                                                                 'iron', all_sprites)\r\n        for x_tree in range(0, self.width, 2):\r\n            for y_tree in range(0, self.width, 2):\r\n                for x in range(randrange(2, 4)):\r\n                    for y in range(randrange(1, 4)):\r\n                        if x * (x_tree + 1) >= self.width or y * (y_tree + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_tree + 1)][y * (y_tree + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_tree + 1)][y * (y_tree + 1)] = Resource(x * (x_tree + 1), y * (y_tree + 1),\r\n                                                                                 'tree', all_sprites)\r\n        for x_food in range(0, self.width, 2):\r\n            for y_food in range(0, self.width, 2):\r\n                for x in range(3):\r\n                    for y in range(randrange(1, 3)):\r\n                        if x * (x_food + 1) >= self.width or y * (y_food + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_food + 1)][y * (y_food + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_food + 1)][y * (y_food + 1)] = Resource(x * (x_food + 1), y * (y_food + 1),\r\n                                                                                 'food', all_sprites)\r\n        self.list[SIZE // 30 // 2][SIZE // 30 // 2] = Castle(SIZE // 30 // 2, SIZE // 30 // 2, all_sprites)\r\n        self.side_size = int(SIZE // 30)\r\n        self.cell_size = 30\r\n        self.top = (SIZE - self.width * self.cell_size) / 2\r\n        self.left = (SIZE - self.width * self.cell_size) / 2\r\n\r\n    def get_cell(self, mouse_pos):\r\n        for i in range(self.height):\r\n            for j in range(self.width):\r\n                if mouse_pos[0] >= self.top + j * self.cell_size and mouse_pos[1] >= self.top + i * self.cell_size and \\\r\n                        mouse_pos[0] <= self.cell_size + self.top + j * self.cell_size and \\\r\n                        mouse_pos[1] <= self.cell_size + self.top + i * self.cell_size:\r\n                    return (i, j)\r\n\r\n    def on_click(self, cell_coords, event):\r\n        if event.button == 1:\r\n            if builder.get_coords() == cell_coords:\r\n                builder.clicked()\r\n            elif scout.get_coords() == cell_coords:\r\n                scout.clicked()\r\n        if (builder.is_clicked or scout.is_clicked) and event.button == 3:\r\n            if builder.can_move(cell_coords):\r\n                builder.move(cell_coords[0], cell_coords[1])\r\n            elif scout.can_move(cell_coords):\r\n                scout.move(cell_coords[0], cell_coords[1])\r\n        print(cell_coords)\r\n\r\n    def get_click(self, mouse_pos, event):\r\n        cell = self.get_cell(mouse_pos)\r\n        self.on_click(cell, event)\r\n\r\n    def render(self):\r\n        for i in range(self.height):\r\n            for j in range(self.width):\r\n                pygame.draw.rect(screen, (255, 255, 255), (self.top + j * self.cell_size, self.top + i * self.cell_size,\r\n                                                           self.cell_size, self.cell_size), 1)\r\n\r\n\r\nclass Human(pygame.sprite.Sprite):\r\n    def __init__(self, pos_x, pos_y, board):\r\n        super().__init__(player_group, all_sprites)\r\n        self.x = pos_x\r\n        self.y = pos_y\r\n        self.board = board\r\n        self.cell_size = 30\r\n        self.is_clicked = False\r\n        self.board.list[pos_x][pos_y] = 'human'\r\n\r\n    def move(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n        self.board.list[self.x][self.y] = 'human'\r\n        self.board.list[x][y] = 'human'\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n\r\n    def unclick(self):\r\n        self.is_clicked = False\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if x == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x + 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y + 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x - 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y - 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n\r\n    '''def clicked(self):\r\n        if self.is_clicked:\r\n            self.is_clicked = False\r\n        else:\r\n            self.is_clicked = True\r\n        for i in range(len(self.board.list)):\r\n            for j in range(len(self.board.list)):\r\n                if self.board.list[i][j]:\r\n                    pass'''\r\n\r\n    def get_coords(self):\r\n        return self.x, self.y\r\n\r\n\r\nclass Builder(Human):\r\n    def __init__(self, pos_x, pos_y, board):\r\n        super().__init__(pos_x, pos_y, board)\r\n        self.image = load_image('player_stand.png')\r\n        self.image = pygame.transform.scale(self.image, (30, 30))\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n\r\n    def clicked(self):\r\n        if self.is_clicked:\r\n            self.is_clicked = False\r\n        else:\r\n            self.is_clicked = True\r\n        builder_screen(self)\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if x == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x + 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y + 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x - 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y - 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n\r\n\r\nclass Scout(Human):\r\n    def __init__(self, x, y, board):\r\n        super().__init__(x, y, board)\r\n        self.image = load_image('scout.png')\r\n        self.image = pygame.transform.scale(self.image, (30, 30))\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n\r\n    def clicked(self):\r\n        if self.is_clicked:\r\n            self.is_clicked = False\r\n        else:\r\n            self.is_clicked = True\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if abs(self.x - x) <= 2 and abs(self.y - y) <= 2 and self.board.list[x][y].__class__.__name__ != 'name':\r\n            return True\r\n\r\n\r\nif __name__ == '__main__':\r\n    pygame.init()\r\n    SIZE, BOARD_SIZE, TOPLEFT = start_screen()\r\n    screen = pygame.display.set_mode((SIZE, SIZE))\r\n    all_sprites = pygame.sprite.Group()\r\n    tiles_group = pygame.sprite.Group()\r\n    player_group = pygame.sprite.Group()\r\n    builder_sprites = pygame.sprite.Group()\r\n    resources_sprites = pygame.sprite.Group()\r\n    board = Board()\r\n    clock = pygame.time.Clock()\r\n    running = True\r\n    builder = Builder(randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2),\r\n                      randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2), board)\r\n    scout = Scout(randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2),\r\n                  randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2), board)\r\n    screen.fill((0, 0, 0))\r\n    player = Player()\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                board.get_click(event.pos, event)\r\n        fon_paint()\r\n        all_sprites.draw(screen)\r\n        board.render()\r\n        builder_sprites.draw(screen)\r\n        resources_screen(player.resources)\r\n        resources_sprites.draw(screen)\r\n        player_group.draw(screen)\r\n        pygame.display.flip()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sas.py b/sas.py
--- a/sas.py	(revision 1187991a31f550edf814278aaf535ee511c345eb)
+++ b/sas.py	(date 1610234503114)
@@ -80,9 +80,6 @@
         if name == 'iron':
             self.image = pygame.transform.scale(load_image('iron.png'), (30, 30))
             self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)
-        if name == 'water':
-            self.image = pygame.transform.scale(load_image('water.jpg'), (30, 30))
-            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)
         if name == 'food':
             self.image = pygame.transform.scale(load_image('food.png'), (30, 30))
             self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)
@@ -222,16 +219,6 @@
         for i in range(self.width):
             for j in range(self.height):
                 self.list[i][j] = Pole(i, j, all_sprites)
-        '''for x_water in range(0, SIZE // 30):
-            for y_water in range():
-                for x in range(3):
-                    for y in range(randrange(1, 5)):
-                        if x * (x_water + 1) > SIZE // 30 or y * (y_water + 1) > SIZE // 30:
-                            continue
-                        if self.list[x * (x_water + 1)][y * (y_water + 1)].__class__.__name__ == 'Resource':
-                            continue
-                        self.list[x * (x_water + 1)][y * (y_water + 1)] = Resource(x * (x_water + 1), y * (y_water + 1),
-                                                                                 'water', all_sprites)'''
         for x_iron in range(0, self.width, 4):
             for y_iron in range(0, self.width, 3):
                 for x in range(randrange(2, 4)):
