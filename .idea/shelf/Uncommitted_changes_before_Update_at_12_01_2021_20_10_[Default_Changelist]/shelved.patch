Index: sas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport sys\r\nfrom PyQt5 import uic  # Импортируем uic\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\r\nimport os\r\nfrom random import randrange\r\n\r\nSIZE = 1000\r\nFPS = 50\r\nCELL_SIZE = 30\r\n\r\n\r\n\r\ndef fon_paint():\r\n    fon = pygame.transform.scale(load_image('fon.jpg'), (SIZE, SIZE))\r\n    screen = pygame.display.set_mode((SIZE, SIZE))\r\n    screen.blit(fon, (0, 0))\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    return image\r\n\r\n\r\nclass Tile(pygame.sprite.Sprite):\r\n    def __init__(self, x, y, sprites):\r\n        super().__init__(sprites)\r\n        self.x = x\r\n        self.y = y\r\n        self.is_clicked = False\r\n\r\n    def click(self):\r\n        self.is_clicked = True\r\n        object_screen(self)\r\n\r\n    def unclick(self):\r\n        self.is_clicked = False\r\n        object_screen(self)\r\n\r\n\r\nclass Field(Tile):\r\n    def __init__(self, x, y, sprites, cell_size):\r\n        super().__init__(x, y, sprites)\r\n        self.image = pygame.transform.scale(load_image('Field.png'), (cell_size, cell_size))\r\n        self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        self.name = 'field'\r\n\r\n\r\nclass Castle(Tile):\r\n    def __init__(self, x, y, sprite):\r\n        super().__init__(x, y, sprite)\r\n        self.x = x\r\n        self.y = y\r\n        self.image = pygame.transform.scale(load_image('castle.jpg'), (30, 30))\r\n        self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n\r\n\r\nclass Player:\r\n    def __init__(self):\r\n        self.resources = {\r\n            'wood': 0,\r\n            'iron': 0,\r\n            'jewelry': 0,\r\n            'food': 0\r\n        }\r\n\r\n    def update_resources(self, name, val):\r\n        self.resourses[name] += val\r\n\r\n\r\nclass Resource(Tile):\r\n    def __init__(self, x, y, name, sprites):\r\n        super().__init__(x, y, sprites)\r\n        self.x = x\r\n        self.y = y\r\n        self.name = name\r\n        self.is_mining = False\r\n        if name == 'tree':\r\n            self.image = pygame.transform.scale(load_image('tree.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'iron':\r\n            self.image = pygame.transform.scale(load_image('iron.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'food':\r\n            self.image = pygame.transform.scale(load_image('food.png'), (30, 30))\r\n            self.rect = self.image.get_rect().move(y * CELL_SIZE + TOPLEFT, x * CELL_SIZE + TOPLEFT)\r\n        if name == 'wood':\r\n            self.image = load_image('wood.png')\r\n            self.image = pygame.transform.scale(self.image, (28, 28))\r\n\r\n    def mine(self):\r\n        if not self.is_mining:\r\n            self.is_mining = True\r\n            print('добывается')\r\n\r\n\r\nclass MyWidget(QMainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        uic.loadUi('untitled.ui', self)  # Загружаем дизайн\r\n        self.is_pushed = False\r\n        self.pushButton.clicked.connect(self.run)\r\n        self.pushButton_2.clicked.connect(self.run)\r\n        self.pushButton_3.clicked.connect(self.run)\r\n\r\n    def run(self):\r\n        size = int(self.sender().text().split('(')[1][0:2])\r\n        self.size = size * 30 + 320\r\n        self.board_size = int(self.sender().text().split('(')[1][0:2])\r\n        self.topleft = int((self.size - size * CELL_SIZE) / 2)\r\n        self.is_pushed = True\r\n        self.close()\r\n\r\n\r\ndef start_screen():\r\n    pygame.init()\r\n    clock = pygame.time.Clock()\r\n    app = QApplication(sys.argv)\r\n    ex = MyWidget()\r\n    ex.show()\r\n    while True:\r\n        if ex.is_pushed:\r\n            return ex.size, ex.board_size, ex.topleft\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n        clock.tick(FPS)\r\n\r\n\r\ndef resources_screen(resources):\r\n    pygame.init()\r\n    resources_sprites = pygame.sprite.Group()\r\n    food = pygame.transform.scale(load_image('food_icon.png'), (50, 50))\r\n    image = load_image('frame_1.png')\r\n    iron = pygame.transform.scale(load_image('iron_icon.png'), (50, 50))\r\n    wood = pygame.transform.scale(load_image('wood_icon.png'), (50, 50))\r\n    brilliant = pygame.transform.scale(load_image('brilliant_icon.png'), (40, 50))\r\n    frame = pygame.sprite.Sprite(resources_sprites)\r\n    wood_i = pygame.sprite.Sprite(resources_sprites)\r\n    iron_i = pygame.sprite.Sprite(resources_sprites)\r\n    food_i = pygame.sprite.Sprite(resources_sprites)\r\n    brilliant_i = pygame.sprite.Sprite(resources_sprites)\r\n    frame.image = image\r\n    frame.rect = frame.image.get_rect()\r\n    frame.rect.x = 0\r\n    frame.rect.y = 0\r\n    iron_i.image = iron\r\n    iron_i.rect = iron_i.image.get_rect()\r\n    iron_i.rect.x = 0\r\n    iron_i.rect.y = 0\r\n    food_i.image = food\r\n    food_i.rect = food_i.image.get_rect()\r\n    food_i.rect.x = SIZE // 4\r\n    food_i.rect.y = 0\r\n    wood_i.image = wood\r\n    wood_i.rect = wood_i.image.get_rect()\r\n    wood_i.rect.x = 2 * SIZE // 4\r\n    wood_i.rect.y = 0\r\n    brilliant_i.image = brilliant\r\n    brilliant_i.rect = brilliant_i.image.get_rect()\r\n    brilliant_i.rect.x = 3 * SIZE // 4\r\n    brilliant_i.rect.y = 0\r\n    font = pygame.font.Font(None, 30)\r\n    resources_sprites.draw(screen)\r\n    count = -1\r\n    for i in resources:\r\n        count += 1\r\n        string_rendered = font.render(str(resources[i]), 1, pygame.Color('black'))\r\n        intro_rect = string_rendered.get_rect()\r\n        text_coord = count * SIZE // 4 + 50\r\n        intro_rect.left = text_coord\r\n        intro_rect.y = 15\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n\r\ndef name_to_text(name):\r\n    font = pygame.font.Font(None, 30)\r\n    string_rendered = font.render(name, 1, pygame.Color('white'))\r\n    intro_rect = string_rendered.get_rect()\r\n    text_coord = SIZE // 2 - 25\r\n    intro_rect.left = text_coord\r\n    intro_rect.y = SIZE - 100\r\n    screen.blit(string_rendered, intro_rect)\r\n    \r\nclass Frame(pygame.sprite.Sprite):\r\n    def __init__(self, sprites):\r\n        super().__init__(sprites)\r\n        self.image = load_image('frame.png')\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x = SIZE // 2 - 150\r\n        self.rect.y = SIZE\r\n\r\n    def call(self, obj):\r\n        if obj.__class__.__name__ == 'Resource':\r\n            pickaxe = pygame.sprite.Sprite(object_sprites)\r\n            pickaxe.image = pygame.transform.scale(load_image('pickaxe.png'), (40, 80))\r\n            pickaxe.rect = pickaxe.image.get_rect()\r\n            pickaxe.rect.x = self.rect.x + 50\r\n            pickaxe.rect.y = self.rect.y + 25\r\n            object = pygame.sprite.Sprite(object_sprites)\r\n            object.image = pygame.transform.scale(obj.image, (100, 100))\r\n            object.rect = object.image.get_rect()\r\n            object.rect.x = self.rect.x + 200\r\n            object.rect.y = self.rect.y\r\n            while self.rect.y > SIZE - 100:\r\n                self.rect.y -= 600 / FPS\r\n                if self.rect.y < SIZE - 100:\r\n                    self.rect.y = SIZE - 100\r\n                pickaxe.rect.y = self.rect.y + 25\r\n                object.rect.y = self.rect.y\r\n                object_sprites.draw(screen)\r\n                pygame.display.flip()\r\n                clock.tick(FPS)\r\n        elif obj.name == 'builder':\r\n            pickaxe = pygame.sprite.Sprite(object_sprites)\r\n            pickaxe.image = pygame.transform.scale(load_image('hammer.png'), (80, 80))\r\n            pickaxe.rect = pickaxe.image.get_rect()\r\n            pickaxe.rect.x = self.rect.x + 50\r\n            pickaxe.rect.y = self.rect.y + 25\r\n            object = pygame.sprite.Sprite(object_sprites)\r\n            object.image = pygame.transform.scale(obj.image, (100, 100))\r\n            object.rect = object.image.get_rect()\r\n            object.rect.x = self.rect.x + 200\r\n            object.rect.y = self.rect.y\r\n            while self.rect.y > SIZE - 100:\r\n                self.rect.y -= 600 / FPS\r\n                if self.rect.y < SIZE - 100:\r\n                    self.rect.y = SIZE - 100\r\n                pickaxe.rect.y = self.rect.y + 25\r\n                object.rect.y = self.rect.y\r\n                object_sprites.draw(screen)\r\n                pygame.display.flip()\r\n                clock.tick(FPS)\r\n        else:\r\n            object = pygame.sprite.Sprite(object_sprites)\r\n            object.image = pygame.transform.scale(obj.image, (100, 100))\r\n            object.rect = object.image.get_rect()\r\n            object.rect.x = self.rect.x + 200\r\n            object.rect.y = self.rect.y\r\n            while self.rect.y > SIZE - 100:\r\n                self.rect.y -= 600 / FPS\r\n                if self.rect.y < SIZE - 100:\r\n                    self.rect.y = SIZE - 100\r\n                object.rect.y = self.rect.y\r\n                object_sprites.draw(screen)\r\n                pygame.display.flip()\r\n                clock.tick(FPS)\r\n\r\n\r\ndef object_screen(obj):\r\n    global object_sprites\r\n    frame = Frame(object_sprites)\r\n    if obj.is_clicked:\r\n        frame.call(obj)\r\n\r\n\r\n\r\nclass Board():\r\n    def __init__(self):\r\n        self.side_size = int(SIZE // 30)\r\n        self.cell_size = 30\r\n        self.width = self.height = BOARD_SIZE\r\n        self.list = [[Field(i, j, all_sprites, self.cell_size) for i in range(self.width)] for j in range(self.height)]\r\n        #  случайная генерация железа, дерева и еды\r\n        for x_iron in range(0, self.width, 4):\r\n            for y_iron in range(0, self.width, 3):\r\n                for x in range(randrange(2, 4)):\r\n                    for y in range(randrange(2, 4)):\r\n                        if x * (x_iron + 1) >= self.width or y * (y_iron + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_iron + 1)][y * (y_iron + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_iron + 1)][y * (y_iron + 1)] = Resource(x * (x_iron + 1), y * (y_iron + 1),\r\n                                                                                 'iron', all_sprites)\r\n        for x_tree in range(0, self.width, 2):\r\n            for y_tree in range(0, self.width, 2):\r\n                for x in range(randrange(2, 4)):\r\n                    for y in range(randrange(1, 4)):\r\n                        if x * (x_tree + 1) >= self.width or y * (y_tree + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_tree + 1)][y * (y_tree + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_tree + 1)][y * (y_tree + 1)] = Resource(x * (x_tree + 1), y * (y_tree + 1),\r\n                                                                                 'tree', all_sprites)\r\n        for x_food in range(0, self.width, 2):\r\n            for y_food in range(0, self.width, 2):\r\n                for x in range(3):\r\n                    for y in range(randrange(1, 3)):\r\n                        if x * (x_food + 1) >= self.width or y * (y_food + 1) >= self.width:\r\n                            continue\r\n                        if self.list[x * (x_food + 1)][y * (y_food + 1)].__class__.__name__ == 'Resource':\r\n                            continue\r\n                        self.list[x * (x_food + 1)][y * (y_food + 1)] = Resource(x * (x_food + 1), y * (y_food + 1),\r\n                                                                                 'food', all_sprites)\r\n\r\n        self.top = (SIZE - self.width * self.cell_size) / 2\r\n        self.left = (SIZE - self.width * self.cell_size) / 2\r\n        self.units = []\r\n        self.units.append(Builder(randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2),\r\n                                  randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2), self))\r\n        self.units.append(Scout(randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2),\r\n                                randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2), self))\r\n\r\n\r\n    def get_cell(self, mouse_pos):\r\n        for i in range(self.height):\r\n            for j in range(self.width):\r\n                if self.top + j * self.cell_size <= mouse_pos[0] <= self.cell_size + self.top + j * self.cell_size and \\\r\n                        self.top + i * self.cell_size <= mouse_pos[1] <= self.cell_size + self.top + i * self.cell_size:\r\n                    return i, j\r\n\r\n    def on_click(self, cell_coords, event):\r\n        if event.button == 1:\r\n            for i in self.units:\r\n                if i.get_coords() == cell_coords:\r\n                    if i.is_clicked:\r\n                        self.list[cell_coords[0]][cell_coords[1]].click()\r\n                        i.unclick()\r\n                        break\r\n                    else:\r\n                        i.click()\r\n                        break\r\n                else:\r\n                    i.unclick()\r\n            else:\r\n                for i in range(len(self.list)):\r\n                    for e in range(len(self.list)):\r\n                        if (i, e) == cell_coords:\r\n                            tile = self.list[i][e]\r\n                            if tile.is_clicked:\r\n                                tile.unclick()\r\n                            else:\r\n                                tile.click()\r\n                        else:\r\n                            tile = self.list[i][e]\r\n                            tile.unclick()\r\n        if event.button == 3:\r\n            for i in self.units:\r\n                if i.is_clicked and i.can_move(cell_coords):\r\n                    i.move(cell_coords[0], cell_coords[1])\r\n                    break\r\n\r\n    def get_click(self, mouse_pos, event):\r\n        cell = self.get_cell(mouse_pos)\r\n        self.on_click(cell, event)\r\n\r\n    def render(self):\r\n        self.top = (SIZE - self.width * self.cell_size) / 2\r\n        self.left = (SIZE - self.width * self.cell_size) / 2\r\n        for i in range(self.height):\r\n            for j in range(self.width):\r\n                for e in self.units:\r\n                    if e.is_clicked:\r\n                        name_to_text(e.name)\r\n                        break\r\n                else:\r\n                    if self.list[i][j].is_clicked:\r\n                        name_to_text(self.list[i][j].name)\r\n                pygame.draw.rect(screen, (255, 255, 255), (self.top + j * self.cell_size, self.top + i\r\n                                                           * self.cell_size, self.cell_size, self.cell_size), 1)\r\n\r\n\r\nclass Human(pygame.sprite.Sprite):\r\n    def __init__(self, pos_x, pos_y, board):\r\n        super().__init__(player_group, all_sprites)\r\n        self.x = pos_x\r\n        self.y = pos_y\r\n        self.board = board\r\n        self.cell_size = 30\r\n        self.is_clicked = False\r\n\r\n    def move(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if x == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x + 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y + 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n        if x - 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return True\r\n        if y - 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return True\r\n\r\n    def click(self):\r\n        self.is_clicked = True\r\n        object_screen(self)\r\n\r\n    def unclick(self):\r\n        self.is_clicked = False\r\n        object_screen(self)\r\n\r\n    def get_coords(self):\r\n        return self.x, self.y\r\n\r\n\r\nclass Builder(Human):\r\n    def __init__(self, pos_x, pos_y, board):\r\n        super().__init__(pos_x, pos_y, board)\r\n        self.image = load_image('player_stand.png')\r\n        self.image = pygame.transform.scale(self.image, (30, 30))\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n        self.name = 'builder'\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if x == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n        if y == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n        if x + 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n        if y + 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n        if x - 1 == self.x:\r\n            if y == self.y:\r\n                return False\r\n            if y + 1 == self.y or y - 1 == self.y:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n        if y - 1 == self.y:\r\n            if x == self.x:\r\n                return False\r\n            if x + 1 == self.x or x - 1 == self.x:\r\n                return (x, y) not in [i.get_coords() for i in self.board.units]\r\n\r\n\r\nclass Scout(Human):\r\n    def __init__(self, x, y, board):\r\n        super().__init__(x, y, board)\r\n        self.image = load_image('scout.png')\r\n        self.image = pygame.transform.scale(self.image, (30, 30))\r\n        self.rect = self.image.get_rect().move(self.y * self.cell_size + TOPLEFT, self.x * self.cell_size + TOPLEFT)\r\n        self.name = 'scout'\r\n\r\n    def can_move(self, coords):\r\n        x = coords[0]\r\n        y = coords[1]\r\n        if abs(self.x - x) <= 2 and abs(self.y - y) <= 2 and (x, y) not in [i.get_coords() for i in self.board.units]:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\nif __name__ == '__main__':\r\n    SIZE, BOARD_SIZE, TOPLEFT = start_screen()\r\n    pygame.init()\r\n    screen = pygame.display.set_mode((SIZE, SIZE))\r\n    all_sprites = pygame.sprite.Group()\r\n    tiles_group = pygame.sprite.Group()\r\n    player_group = pygame.sprite.Group()\r\n    object_sprites = pygame.sprite.Group()\r\n    resources_sprites = pygame.sprite.Group()\r\n    board = Board()\r\n    clock = pygame.time.Clock()\r\n    running = True\r\n    screen.fill((0, 0, 0))\r\n    player = Player()\r\n    plus = 0\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                board.get_click(event.pos, event)\r\n        fon_paint()\r\n        all_sprites.draw(screen)\r\n        object_sprites.draw(screen)\r\n        board.render()\r\n        resources_screen(player.resources)\r\n        resources_sprites.draw(screen)\r\n        player_group.draw(screen)\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sas.py b/sas.py
--- a/sas.py	(revision 2ddb4a279c23c53fbc8ccebb12c4d9dd979021d1)
+++ b/sas.py	(date 1610390779403)
@@ -10,7 +10,6 @@
 CELL_SIZE = 30
 
 
-
 def fon_paint():
     fon = pygame.transform.scale(load_image('fon.jpg'), (SIZE, SIZE))
     screen = pygame.display.set_mode((SIZE, SIZE))
@@ -190,7 +189,8 @@
     intro_rect.left = text_coord
     intro_rect.y = SIZE - 100
     screen.blit(string_rendered, intro_rect)
-    
+
+
 class Frame(pygame.sprite.Sprite):
     def __init__(self, sprites):
         super().__init__(sprites)
@@ -263,7 +263,6 @@
         frame.call(obj)
 
 
-
 class Board():
     def __init__(self):
         self.side_size = int(SIZE // 30)
@@ -310,7 +309,6 @@
         self.units.append(Scout(randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2),
                                 randrange(SIZE // 30 // 2 - 2, SIZE // 30 // 2 + 2), self))
 
-
     def get_cell(self, mouse_pos):
         for i in range(self.height):
             for j in range(self.width):
